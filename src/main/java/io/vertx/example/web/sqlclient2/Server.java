/*
 * Copyright 2014 Red Hat, Inc.
 *
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *  The Eclipse Public License is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  The Apache License v2.0 is available at
 *  http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.example.web.sqlclient2;

import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.core.json.jackson.DatabindCodec;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Pool;
import io.vertx.sqlclient.PoolOptions;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.SqlConnectOptions;
import io.vertx.sqlclient.SqlResult;
import io.vertx.sqlclient.templates.RowMapper;
import io.vertx.sqlclient.templates.SqlTemplate;
import io.vertx.sqlclient.templates.TupleMapper;

/**
 * @author <a href="mailto:pmlopes@gmail.com">Paulo Lopes</a>
 */
public class Server extends AbstractVerticle {

  public static void main(String[] args) {
  }

  Random random = new Random();

  static {
    DatabindCodec.mapper().registerModule(new JavaTimeModule());
    DatabindCodec.mapper().disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    boolean useSqlClient = Boolean.parseBoolean(System.getProperty("useSqlClient", "false"));
    // agroal or hikari
    String cpProvider = System.getProperty("cpProvider", "agroal");
    String dbUserName = config().getString("dbUserName", "test");
    String dbPassword = config().getString("dbPassword", "test");
    String dbHostName = config().getString("dbHostName", "localhost");
    int dbPortNumber = config().getInteger("dbPortNumber", 5432);
    String dbName = config().getString("dbName", "test");
    int maxPoolSize = config().getInteger("maxPoolSize", 4);
    String jdbcUrl = "jdbc:postgresql://" + dbHostName + ":" + dbPortNumber + "/" + dbName;
    Pool pool;
    SqlTemplate<Map<String, Object>, RowSet<JsonObject>> getProductListTmpl;
    SqlTemplate<JsonObject, SqlResult<Void>> addProductTmpl;
    List<JsonObject> testData;
    int testDataIdxStart = randomInt();

    log("useSqlClient: " + useSqlClient);

    if (useSqlClient) {
      SqlConnectOptions options = new SqlConnectOptions().setPort(dbPortNumber).setHost(dbHostName).setDatabase(dbName)
          .setUser(dbUserName).setPassword(dbPassword);
      pool = Pool.pool(vertx, options, new PoolOptions().setMaxSize(maxPoolSize));
    } else {
      log("cpProvider: " + cpProvider);
      if ("hikari".equals(cpProvider)) {
        JsonObject config = new JsonObject()
            .put("provider_class", "io.vertx.ext.jdbc.spi.impl.HikariCPDataSourceProvider")
            .put("driverClassName", "org.postgresql.Driver").put("jdbcUrl", jdbcUrl).put("username", dbUserName)
            .put("password", dbPassword).put("maximumPoolSize", maxPoolSize).put("autoGeneratedKeys", false);
        pool = JDBCPool.pool(vertx, config);
      } else {
        // Agroal
        JDBCConnectOptions options = new JDBCConnectOptions().setJdbcUrl(jdbcUrl).setUser(dbUserName)
            .setPassword(dbPassword).setAutoGeneratedKeys(false).setMetricsEnabled(true);
        pool = JDBCPool.pool(vertx, options, new PoolOptions().setMaxSize(maxPoolSize));
      }
    }

    addProductTmpl = SqlTemplate.forUpdate(pool,
        "INSERT INTO products (id, name, price, weight, expiry_time) VALUES (#{id}, #{name}, #{price}, #{weight}, #{expiry_time})")
        .mapFrom(TupleMapper.jsonObject());
    getProductListTmpl = SqlTemplate
        .forQuery(pool,
            "SELECT id, name, price, weight, expiry_time FROM products where id >= #{id1} and id <= #{id2} order by id")
        .mapTo(getRowMapperForTestData());

    testData = getTestData(testDataIdxStart);
    pool.query(
        "CREATE TABLE IF NOT EXISTS products(id INT not null , name VARCHAR(255), price FLOAT, weight INT, expiry_time timestamptz(0) null)")
        .execute().compose(res -> addProductTmpl.executeBatch(testData)).onFailure(e -> {
          log("insert records failed " + e);
        }).compose(v -> {

          Map<String, Object> input = new HashMap<>();
          input.put("id1", testDataIdxStart + 1);
          input.put("id2", testDataIdxStart + 3);
          AtomicInteger x = new AtomicInteger(0);
          getProductListTmpl.execute(input).onSuccess(rows -> {
            rows.forEach(row -> {
              if (!testData.get(x.get()).equals(row)) {
                log("row " + x.get() + " read DOES NOT MATCH test data");
                log("test " + x.get() + ":" + testData.get(x.get()));
                log("row   :" + row + "\n");
                // log("equal? " + testData.get(x.get()).equals(row));
              } else {
                log("row " + x.get() + " read matches test data");
              }
              x.getAndIncrement();
            });
          });
          return Future.succeededFuture();
        }).<Void>mapEmpty().onComplete(startPromise).onComplete(x -> {
          this.vertx.setTimer(2000, id -> {
            this.vertx.close();
          });
        });
  }

  private int randomInt() {
    return random.ints(1, 999999).findAny().getAsInt();
  }

  private List<JsonObject> getTestData(int st) {
    return Arrays.asList(
        new JsonObject().put("id", st + 1).put("name", "Egg Whisk").put("price", 3.99f).put("weight", 150)
            .put("expiry_time", OffsetDateTime.now(ZoneId.of("UTC")).truncatedTo(ChronoUnit.SECONDS).plusDays(1)),
        new JsonObject().put("id", st + 2).put("name", "Tea Cosy").put("price", 5.99f).put("weight", 100)
            .put("expiry_time", OffsetDateTime.now(ZoneId.of("UTC")).truncatedTo(ChronoUnit.SECONDS).plusDays(2)),
        new JsonObject().put("id", st + 3).put("name", "Spatula").put("price", 1.00f).put("weight", 80)
            .put("expiry_time", OffsetDateTime.now(ZoneId.of("UTC")).truncatedTo(ChronoUnit.SECONDS).plusDays(3)));
  }

  private RowMapper<JsonObject> getRowMapperForTestData() {
    return row -> {
      JsonObject obj = new JsonObject();
      obj.put("id", row.getInteger("id")).put("name", row.getString("name")).put("price", row.getFloat("price"))
          .put("weight", row.getInteger("weight")).put("expiry_time", row.getOffsetDateTime("expiry_time"));
      return obj;
    };
  }

  private void log(String s) {
    System.out.println(s);
  }
}
